diff --git a/patches/afl/afl-fuzz.c b/patches/afl/afl-fuzz.c
index fc18643..0e943de 100644
--- a/patches/afl/afl-fuzz.c
+++ b/patches/afl/afl-fuzz.c
@@ -245,6 +245,7 @@ int comm_server(int mode) {
     struct addrinfo hints, *servinfo, *p;
     int rv;
     char s[INET6_ADDRSTRLEN];
+    int connection_trials = 0;
 
     memset(&hints, 0, sizeof hints);
     hints.ai_family = AF_UNSPEC;
@@ -254,6 +255,7 @@ int comm_server(int mode) {
         fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
         return 1;
     }
+try_again:
     for (p = servinfo; p != NULL; p = p->ai_next) {
         if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
             perror("client:socket");
@@ -270,7 +272,12 @@ int comm_server(int mode) {
     }
 
     if (p == NULL) {
-        fprintf(stderr, "client: failed to connect\n");
+        fprintf(stderr, "client: failed to connect (trial %d)\n", connection_trials+1);
+        if (connection_trials < 120) {
+            connection_trials++;
+            sleep(1);
+            goto try_again;
+        }
         return 2;
     }
 
diff --git a/patches/afl/afl-llvm-pass.so.cc b/patches/afl/afl-llvm-pass.so.cc
index a928476..f4faf50 100644
--- a/patches/afl/afl-llvm-pass.so.cc
+++ b/patches/afl/afl-llvm-pass.so.cc
@@ -157,7 +157,14 @@ class AFLCoverage : public ModulePass {
         "getSBoxValue",
         "BlockCopy",
         "xtime",
-        "cgc_xor"
+        "cgc_xor",
+        "OPENSSL_cpuid_setup",
+        "resolve_addslashes",
+        "resolve_base64_decode",
+        "resolve_base64_encode",
+        "resolve_crc32_x86_simd_update",
+        "resolve_stripslashes",
+        "zend_cpu_supports_"
 	    // These functions form a part of the libcgc and as such does not make sense to instrument these
         // "_pcre_find_bracket",
         // "_pcre_is_newline",
diff --git a/patches/svf/svf-ex.cpp b/patches/svf/svf-ex.cpp
index 167f5d4..caaf30e 100644
--- a/patches/svf/svf-ex.cpp
+++ b/patches/svf/svf-ex.cpp
@@ -68,6 +68,8 @@ static llvm::cl::opt<bool> GetIndirect("get-indirect", llvm::cl::init(false), ll
 // Switch to enable the static analysis to be run in client-server mode with the fuzzer as the client 
 static llvm::cl::opt<bool> RunServer("run-server", llvm::cl::init(false), llvm::cl::desc("run static analysis server for interfacing with fuzzer")); 
 
+static llvm::cl::opt<std::string> PreprocessingDoneFile("preprocessing-done", llvm::cl::desc("Specify file to be used for checking if preprocessing is done"), llvm::cl::value_desc("File to be used for checking if preprocessing is done"));
+
 int main(int argc, char ** argv) {
 
     int arg_num = 0;
@@ -114,6 +116,14 @@ int main(int argc, char ** argv) {
     auto end = chrono::steady_clock::now(); 
     spdlog::info("Time taken to build structures:{}", chrono::duration_cast<chrono::milliseconds>(end - start).count());
 
+    // Write time taken to PreprocessingDoneFile
+    if (!PreprocessingDoneFile.empty()) {
+        std::ofstream outfile;
+        outfile.open(PreprocessingDoneFile);
+        outfile << chrono::duration_cast<chrono::milliseconds>(end - start).count();
+        outfile.close();
+    }
+
     // Get the port to run the static analysis server on
     std::string port = Port;
 
diff --git a/patches/svf/util.cpp b/patches/svf/util.cpp
index bf87cd6..2d5573e 100644
--- a/patches/svf/util.cpp
+++ b/patches/svf/util.cpp
@@ -78,11 +78,16 @@ PTACallGraphNode* get_callgraph_node(
     const Function *target_function = NULL;
     for (SVFModule::llvm_const_iterator I = svfModule->llvmFunBegin(), E =
                 svfModule->llvmFunEnd(); I != E; ++I) {
-        if ((target.compare((*I)->getName().str())) == 0) { 
+        std::string demangled_fn = demangleString((*I)->getName().str().c_str());
+        if ((target.compare(demangled_fn)) == 0) { 
 	        target_function = *I;
             break;
         }
     }
+    if (target_function == NULL) {
+        spdlog::critical("{}: could not find function: {}", __func__, target);
+        abort();
+    }
     const SVFFunction* target_svf = svfModule->getSVFFunction(target_function);
     PTACallGraphNode* target_node = callgraph->getCallGraphNode(target_svf);
     return target_node;
